// Code generated by validators.py; DO NOT EDIT.
package validate

import (
	"github.com/metafates/schema/constraint"
	"github.com/metafates/schema/validate/charset"
)

// Any accepts any value of T.
type Any[T any] struct{}

// Zero accepts all zero values.
//
// The zero value is:
// - 0 for numeric types,
// - false for the boolean type, and
// - "" (the empty string) for strings.
//
// See [NonZero].
type Zero[T comparable] struct{}

// NonZero accepts all non-zero values.
//
// The zero value is:
// - 0 for numeric types,
// - false for the boolean type, and
// - "" (the empty string) for strings.
//
// See [Zero].
type NonZero[T comparable] struct{}

// Positive accepts all positive real numbers excluding zero.
//
// See [Positive0] for zero including variant.
type Positive[T constraint.Real] struct{}

// Negative accepts all negative real numbers excluding zero.
//
// See [Negative0] for zero including variant.
type Negative[T constraint.Real] struct{}

// Positive0 accepts all positive real numbers including zero.
//
// See [Positive] for zero excluding variant.
type Positive0[T constraint.Real] struct{
	Or[T, Positive[T], Zero[T]]
}

// Negative0 accepts all negative real numbers including zero.
//
// See [Negative] for zero excluding variant.
type Negative0[T constraint.Real] struct{
	Or[T, Negative[T], Zero[T]]
}

// Even accepts integers divisible by two.
type Even[T constraint.Integer] struct{}

// Odd accepts integers not divisible by two.
type Odd[T constraint.Integer] struct{}

// Email accepts a single RFC 5322 address, e.g. "Barry Gibbs <bg@example.com>".
type Email[T constraint.Text] struct{}

// URL accepts a single url.
// The url may be relative (a path, without a host) or absolute (starting with a scheme).
//
// See also [HTTPURL].
type URL[T constraint.Text] struct{}

// HTTPURL accepts a single http(s) url.
//
// See also [URL].
type HTTPURL[T constraint.Text] struct{}

// IP accepts an IP address.
// The address can be in dotted decimal ("192.0.2.1"),
// IPv6 ("2001:db8::68"), or IPv6 with a scoped addressing zone ("fe80::1cc0:3e8c:119f:c2e1%ens18").
type IP[T constraint.Text] struct{}

// IPV4 accepts an IP V4 address (e.g. "192.0.2.1").
type IPV4[T constraint.Text] struct{}

// IPV6 accepts an IP V6 address, including IPv4-mapped IPv6 addresses.
// The address can be regular IPv6 ("2001:db8::68"), or IPv6 with
// a scoped addressing zone ("fe80::1cc0:3e8c:119f:c2e1%ens18").
type IPV6[T constraint.Text] struct{}

// MAC accepts an IEEE 802 MAC-48, EUI-48, EUI-64, or a 20-octet IP over InfiniBand link-layer address.
type MAC[T constraint.Text] struct{}

// CIDR accepts CIDR notation IP address and prefix length,
// like "192.0.2.0/24" or "2001:db8::/32", as defined in RFC 4632 and RFC 4291.
type CIDR[T constraint.Text] struct{}

// Base64 accepts valid base64 encoded strings.
type Base64[T constraint.Text] struct{}

// Charset0 accepts (possibly empty) text which contains only runes acceptable by filter.
// See [Charset] for a non-empty variant.
type Charset0[T constraint.Text, F charset.Filter] struct{}

// Charset accepts non-empty text which contains only runes acceptable by filter.
// See also [Charset0].
type Charset[T constraint.Text, F charset.Filter] struct{}

// Latitude accepts any number in the range [-90; 90].
//
// See also [Longitude].
type Latitude[T constraint.Real] struct{}

// Longitude accepts any number in the range [-180; 180].
//
// See also [Latitude].
type Longitude[T constraint.Real] struct{}

// InFuture accepts any time after current timestamp.
//
// See also [InPast].
type InPast[T constraint.Time] struct{}

// InFuture accepts any time after current timestamp.
//
// See also [InPast].
type InFuture[T constraint.Time] struct{}

// Unique accepts a slice-like of unique values.
//
// See [UniqueSlice] for a slice shortcut.
type Unique[S ~[]T, T comparable] struct{}

// Unique accepts a slice of unique values.
//
// See [Unique] for a more generic version.
type UniqueSlice[T comparable] struct{
	Unique[[]T, T]
}

// NonEmpty accepts a non-empty slice-like (len > 0).
//
// See [NonEmptySlice] for a slice shortcut.
type NonEmpty[S ~[]T, T any] struct{}

// NonEmptySlice accepts a non-empty slice (len > 0).
//
// See [NonEmpty] for a more generic version.
type NonEmptySlice[T comparable] struct{
	NonEmpty[[]T, T]
}

// MIME accepts RFC 1521 mime type string.
type MIME[T constraint.Text] struct{}

// UUID accepts a properly formatted UUID in one of the following formats:
//   - xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
//   - urn:uuid:xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
//   - xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
//   - {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
type UUID[T constraint.Text] struct{}

// JSON accepts valid json encoded text.
type JSON[T constraint.Text] struct{}

// CountryAlpha2 accepts case-insensitive ISO 3166 2-letter country code.
type CountryAlpha2[T constraint.Text] struct{}

// CountryAlpha3 accepts case-insensitive ISO 3166 3-letter country code.
type CountryAlpha3[T constraint.Text] struct{}

// CountryAlpha accepts either [CountryAlpha2] or [CountryAlpha3].
type CountryAlpha[T constraint.Text] struct{
	Or[T, CountryAlpha2[T], CountryAlpha3[T]]
}

// CurrencyAlpha accepts case-insensitive ISO 4217 alphabetic currency code.
type CurrencyAlpha[T constraint.Text] struct{}

// LangAlpha2 accepts case-insensitive ISO 639 2-letter language code.
type LangAlpha2[T constraint.Text] struct{}

// LangAlpha3 accepts case-insensitive ISO 639 3-letter language code.
type LangAlpha3[T constraint.Text] struct{}

// LangAlpha accepts either [LangAlpha2] or [LangAlpha3].
type LangAlpha[T constraint.Text] struct{
	Or[T, LangAlpha2[T], LangAlpha3[T]]
}

// And is a meta validator that combines other validators with AND operator.
// Validators are called in the same order as specified by type parameters.
//
// See also [Or], [Not].
type And[T any, A Validator[T], B Validator[T]] struct{}

// Or is a meta validator that combines other validators with OR operator.
// Validators are called in the same order as type parameters.
//
// See also [And], [Not].
type Or[T any, A Validator[T], B Validator[T]] struct{}

// Not is a meta validator that inverts given validator.
//
// See also [And], [Or].
type Not[T any, V Validator[T]] struct{}

