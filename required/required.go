// Code generated by gen.py; DO NOT EDIT.
package required

import (
	"github.com/metafates/schema/constraint"
	"github.com/metafates/schema/validate"
	"github.com/metafates/schema/validate/charset"
)

// Any accepts any value of T.
type Any[T any] = Custom[T, validate.Any[T]]

// Zero accepts all zero values.
//
// The zero value is:
// - 0 for numeric types,
// - false for the boolean type, and
// - "" (the empty string) for strings.
//
// See [NonZero].
type Zero[T comparable] = Custom[T, validate.Zero[T]]

// NonZero accepts all non-zero values.
//
// The zero value is:
// - 0 for numeric types,
// - false for the boolean type, and
// - "" (the empty string) for strings.
//
// See [Zero].
type NonZero[T comparable] = Custom[T, validate.NonZero[T]]

// Positive accepts all positive real numbers excluding zero.
//
// See [Positive0] for zero including variant.
type Positive[T constraint.Real] = Custom[T, validate.Positive[T]]

// Negative accepts all negative real numbers excluding zero.
//
// See [Negative0] for zero including variant.
type Negative[T constraint.Real] = Custom[T, validate.Negative[T]]

// Positive0 accepts all positive real numbers including zero.
//
// See [Positive] for zero excluding variant.
type Positive0[T constraint.Real] = Custom[T, validate.Positive0[T]]

// Negative0 accepts all negative real numbers including zero.
//
// See [Negative] for zero excluding variant.
type Negative0[T constraint.Real] = Custom[T, validate.Negative0[T]]

// Even accepts integers divisible by two.
type Even[T constraint.Integer] = Custom[T, validate.Even[T]]

// Odd accepts integers not divisible by two.
type Odd[T constraint.Integer] = Custom[T, validate.Odd[T]]

// Email accepts a single RFC 5322 address, e.g. "Barry Gibbs <bg@example.com>".
type Email[T constraint.Text] = Custom[T, validate.Email[T]]

// URL accepts a single url.
// The url may be relative (a path, without a host) or absolute (starting with a scheme).
//
// See also [HTTPURL].
type URL[T constraint.Text] = Custom[T, validate.URL[T]]

// HTTPURL accepts a single http(s) url.
//
// See also [URL].
type HTTPURL[T constraint.Text] = Custom[T, validate.HTTPURL[T]]

// IP accepts an IP address.
// The address can be in dotted decimal ("192.0.2.1"),
// IPv6 ("2001:db8::68"), or IPv6 with a scoped addressing zone ("fe80::1cc0:3e8c:119f:c2e1%ens18").
type IP[T constraint.Text] = Custom[T, validate.IP[T]]

// IPV4 accepts an IP V4 address (e.g. "192.0.2.1").
type IPV4[T constraint.Text] = Custom[T, validate.IPV4[T]]

// IPV6 accepts an IP V6 address, including IPv4-mapped IPv6 addresses.
// The address can be regular IPv6 ("2001:db8::68"), or IPv6 with
// a scoped addressing zone ("fe80::1cc0:3e8c:119f:c2e1%ens18").
type IPV6[T constraint.Text] = Custom[T, validate.IPV6[T]]

// MAC accepts an IEEE 802 MAC-48, EUI-48, EUI-64, or a 20-octet IP over InfiniBand link-layer address.
type MAC[T constraint.Text] = Custom[T, validate.MAC[T]]

// CIDR accepts CIDR notation IP address and prefix length,
// like "192.0.2.0/24" or "2001:db8::/32", as defined in RFC 4632 and RFC 4291.
type CIDR[T constraint.Text] = Custom[T, validate.CIDR[T]]

// Base64 accepts valid base64 encoded strings.
type Base64[T constraint.Text] = Custom[T, validate.Base64[T]]

// Charset0 accepts (possibly empty) text which contains only runes acceptable by filter.
// See [Charset] for a non-empty variant.
type Charset0[T constraint.Text, F charset.Filter] = Custom[T, validate.Charset0[T, F]]

// Charset accepts non-empty text which contains only runes acceptable by filter.
// See also [Charset0].
type Charset[T constraint.Text, F charset.Filter] = Custom[T, validate.Charset[T, F]]

// Latitude accepts any number in the range [-90; 90].
//
// See also [Longitude].
type Latitude[T constraint.Real] = Custom[T, validate.Latitude[T]]

// Longitude accepts any number in the range [-180; 180].
//
// See also [Latitude].
type Longitude[T constraint.Real] = Custom[T, validate.Longitude[T]]

// InFuture accepts any time after current timestamp.
//
// See also [InPast].
type InPast[T constraint.Time] = Custom[T, validate.InPast[T]]

// InFuture accepts any time after current timestamp.
//
// See also [InPast].
type InFuture[T constraint.Time] = Custom[T, validate.InFuture[T]]

// Unique accepts a slice-like of unique values.
//
// See [UniqueSlice] for a slice shortcut.
type Unique[S ~[]T, T comparable] = Custom[S, validate.Unique[S, T]]

// Unique accepts a slice of unique values.
//
// See [Unique] for a more generic version.
type UniqueSlice[T comparable] = Custom[[]T, validate.UniqueSlice[T]]

// NonEmpty accepts a non-empty slice-like (len > 0).
//
// See [NonEmptySlice] for a slice shortcut.
type NonEmpty[S ~[]T, T any] = Custom[S, validate.NonEmpty[S, T]]

// NonEmptySlice accepts a non-empty slice (len > 0).
//
// See [NonEmpty] for a more generic version.
type NonEmptySlice[T comparable] = Custom[[]T, validate.NonEmptySlice[T]]

// MIME accepts RFC 1521 mime type string.
type MIME[T constraint.Text] = Custom[T, validate.MIME[T]]

// UUID accepts a properly formatted UUID in one of the following formats:
//   xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
//   urn:uuid:xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
//   xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
//   {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
type UUID[T constraint.Text] = Custom[T, validate.UUID[T]]

// JSON accepts valid json encoded text.
type JSON[T constraint.Text] = Custom[T, validate.JSON[T]]

// CountryAlpha2 accepts case-insensitive ISO 3166 2-letter country code.
type CountryAlpha2[T constraint.Text] = Custom[T, validate.CountryAlpha2[T]]

// CountryAlpha3 accepts case-insensitive ISO 3166 3-letter country code.
type CountryAlpha3[T constraint.Text] = Custom[T, validate.CountryAlpha3[T]]

// CountryAlpha accepts either [CountryAlpha2] or [CountryAlpha3].
type CountryAlpha[T constraint.Text] = Custom[T, validate.CountryAlpha[T]]

// CurrencyAlpha accepts case-insensitive ISO 4217 alphabetic currency code.
type CurrencyAlpha[T constraint.Text] = Custom[T, validate.CurrencyAlpha[T]]

// LangAlpha2 accepts case-insesitive ISO 639 2-letter language code.
type LangAlpha2[T constraint.Text] = Custom[T, validate.LangAlpha2[T]]

// LangAlpha3 accepts case-insesitive ISO 639 3-letter language code.
type LangAlpha3[T constraint.Text] = Custom[T, validate.LangAlpha3[T]]

// LangAlpha accepts either [LangAlpha2] or [LangAlpha3].
type LangAlpha[T constraint.Text] = Custom[T, validate.LangAlpha[T]]
