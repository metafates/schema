// Code generated by schemagen; DO NOT EDIT.

package main

import (
	"fmt"
	"github.com/metafates/schema/optional"
	"github.com/metafates/schema/required"
	"github.com/metafates/schema/validate"
	"github.com/metafates/schema/validate/charset"
	"time"
)

// Ensure that [User] type was not changed
func _() {
	type locked struct {
		ID    required.Custom[string, validate.UUID[string]]                   `json:"id"`
		Name  required.Custom[string, validate.Charset[string, charset.Print]] `json:"name"`
		Birth optional.Custom[time.Time, validate.InPast[time.Time]]           `json:"birth"`
		Meta  struct {
			Preferences optional.Custom[[]string, validate.UniqueSlice[string]] `json:"preferences"`
			Admin       bool                                                    `json:"admin"`
		} `json:"meta"`
		Friends   []UserFriend `json:"friends"`
		Addresses []struct {
			Tag       optional.Custom[string, validate.Charset[string, charset.Print]] `json:"tag"`
			Latitude  required.Custom[float64, validate.Latitude[float64]]             `json:"latitude"`
			Longitude required.Custom[float64, validate.Longitude[float64]]            `json:"longitude"`
		} `json:"addresses"`
	}
	var v User
	// Compiler error signifies that the type definition have changed.
	// Re-run the schemagen command to regenerate this file.
	_ = locked(v)
}

// TypeValidate implements the [validate.TypeValidateable] interface.
func (x *User) TypeValidate() error {
	err0 := validate.Validate(&x.ID)
	if err0 != nil {
		return validate.ValidationError{Inner: err0}.WithPath(fmt.Sprintf(".ID"))
	}
	err1 := validate.Validate(&x.Name)
	if err1 != nil {
		return validate.ValidationError{Inner: err1}.WithPath(fmt.Sprintf(".Name"))
	}
	err2 := validate.Validate(&x.Birth)
	if err2 != nil {
		return validate.ValidationError{Inner: err2}.WithPath(fmt.Sprintf(".Birth"))
	}
	err3 := validate.Validate(&x.Meta.Preferences)
	if err3 != nil {
		return validate.ValidationError{Inner: err3}.WithPath(fmt.Sprintf(".Meta.Preferences"))
	}
	for i0 := range x.Friends {
		{
			err4 := validate.Validate(&x.Friends[i0])
			if err4 != nil {
				return validate.ValidationError{Inner: err4}.WithPath(fmt.Sprintf(".Friends[%v]", i0))
			}
		}
	}
	for i1 := range x.Addresses {
		{
			err5 := validate.Validate(&x.Addresses[i1].Tag)
			if err5 != nil {
				return validate.ValidationError{Inner: err5}.WithPath(fmt.Sprintf(".Addresses[%v].Tag", i1))
			}
			err6 := validate.Validate(&x.Addresses[i1].Latitude)
			if err6 != nil {
				return validate.ValidationError{Inner: err6}.WithPath(fmt.Sprintf(".Addresses[%v].Latitude", i1))
			}
			err7 := validate.Validate(&x.Addresses[i1].Longitude)
			if err7 != nil {
				return validate.ValidationError{Inner: err7}.WithPath(fmt.Sprintf(".Addresses[%v].Longitude", i1))
			}
		}
	}
	return nil
}
